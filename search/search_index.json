{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"zMultilogue","text":"<p>zMultilogue is a plugin that implements Multi-NPC dialog system for Gothic 1 and Gothic 2 NotR. Its working principle is based on the solution from AFSP Trialogue package. The main project goal is to replace Trialog packages based on Ikarus and LeGo with an union-based plugin.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>System for creating dialogs with multiple NPCs without breaking the AI queue</li> <li>Manual script interface based on the LeGo Trialoge package</li> <li>Auto script interface that makes writing multilogs as easy as normal dialogs</li> <li>Advanced camera manipulation system</li> </ul>"},{"location":"#authors","title":"Authors","text":"<p>zMultilogue started as a quick replacement for Trialogs when getting rid of Ikarus in The Story of Nek codebase. Later evolved into a more complex dialog system enhancement. It was published as open-source project under MIT License<sup>1</sup> almost instantly when the main features were ready, since there were no union-based alternative available at the time.</p> <p>The project is maintained under Silver Ore Team modding group by muczc1wek:</p> <ul> <li>Email: mateusz.uczciwek@silveroreteam.pl</li> <li>Discord: @muczc1wek</li> </ul> <p>Below you can find the contributors to the project:</p> <p></p> <ol> <li> <p>zMultilogue depends on union-api and gothic-api libraries, which are licensed under BSD 3-Clause \"New\" or \"Revised\" License and GothicVDFS 2.6 Copyright (c) 2001-2003, Nico Bendlin, Copyright (c) 1994-2002, Peter Sabath / TRIACOM Software GmbH \u21a9</p> </li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you to install and set up zMultilogue plugin for your gothic mod.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You have to have Union installed to use zMultilogue.</p>"},{"location":"getting-started/#global","title":"Global","text":"<ol> <li>Download the <code>zMultilogue-&lt;version&gt;.vdf</code> form latest release.</li> <li>Place the file inside <code>&lt;GOTHIC_ROOT&gt;/Data</code> with to automatically load the plugin at the start of the game.</li> </ol> <p>Warning</p> <p>Global installation is recommended for mod development phase. You should not use it for your final mod release.</p>"},{"location":"getting-started/#mod","title":"Mod","text":"<ol> <li>Download the <code>zMultilogue-&lt;version&gt;.vdf</code> form latest release.</li> <li>Rename the file to <code>zMultilogue.mod</code>, place it inside <code>&lt;GOTHIC_ROOT&gt;/Data/ModVDF</code>.</li> <li>In <code>YourMod.ini</code> add the file into <code>[FILES].VDF</code> key:</li> </ol> <pre><code>[FILES]\n; NOTICE DOUBLE SPACE!\n; If you use multiple VDF files, \n; you have to separate them with TWO spaces\nVDF=YourMod.mod  zMultilogue.mod\n</code></pre>"},{"location":"getting-started/#setup","title":"Setup","text":"<p>Since <code>v0.1.9</code> there is no need to include <code>ZS_MULTILOGUE</code> routine. It is now done automatically with zParserExtender.</p> <p>Deprecated</p> <p>To make the plugin work you have to add the <code>ZS_MULTILOGUE</code> routine to your scripts. <pre><code>func void ZS_MULTILOGUE() {\n};\n\nfunc int ZS_MULTILOGUE_LOOP() {\n    if (InfoManager_hasFinished()) {\n        return LOOP_END;\n    } else {\n        return LOOP_CONTINUE;\n    };\n};\n\nfunc void ZS_MULTILOGUE_END() {\n};\n</code></pre> The best way to do it is to create a new file, for example <code>ZS_MULTILOGUE.d</code> and place it among other routines.</p> <p>MAKE SURE THAT THIS FILE IS INCLUDED IN <code>GOTHIC.SRC</code></p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>zMultilogue allows you to set some options with .ini parameters.</p>"},{"location":"getting-started/#logging","title":"Logging","text":"<p>By default, we print only the severity <code>&gt;=INFO</code> to Union Console and <code>&gt;=DEBUG</code> to ZSpy. To print all logs to the console, you can set <code>TRACE</code> logging level in <code>Gothic.ini</code>: <pre><code>[ZMULTILOGUE]\n; Logger levels:\n; NONE, FATAL, ERROR, WARN, INFO, DEBUG, TRACE\nLoggerLevelUnion=TRACE\nLoggerLevelZSpy=TRACE\n</code></pre></p> <p>Tip</p> <p>Logs form zMultilogue start with <code>zMul</code> prefix, so you can recognize them easily.</p>"},{"location":"scripting/","title":"Scripting","text":"<p>This section provides an overview of the scripting API and how to utilize the zMultilogue plugin in your Gothic mod.</p>"},{"location":"scripting/camera/","title":"Camera System","text":"<p>zMultilogue provides a powerful camera system that allows you to take control over the dialog camera during conversations. This is particularly useful when creating multilogs where default camera could not be enough. The camera system is independent of the main multilog system, meaning you can use it in any dialog.</p>"},{"location":"scripting/camera/#working-principle","title":"Working principle","text":"<p>Dialog camera operates based on <code>Source</code> and <code>Target</code> vobs<sup>1</sup>. <code>Source</code> is the object from behind which the camera is casted and <code>Target</code> is the object at which the camera is casted. At every <code>AI_Output()</code> call it is checked if the speaker has changed and if so the camera event is executed. zMultilogue allows to change <code>Source</code> and <code>Target</code> and also ecxeute camera events independent.</p>"},{"location":"scripting/camera/#camera-modes","title":"Camera modes","text":"<ol> <li>Default - Default dialog camera</li> <li>Advanced - <code>Source</code> and <code>Target</code> are controlled by the user, camera events are automatic</li> <li>Full - <code>Source</code>, <code>Target</code> and camera events are controlled by the user</li> </ol>"},{"location":"scripting/camera/#functions","title":"Functions","text":""},{"location":"scripting/camera/#zmulcam_setmode","title":"<code>zMulCam_SetMode</code>","text":"<p>Changes the camera mode <pre><code>func void zMulCam_SetMode(var int mode) {};\n</code></pre> Parameters</p> <ul> <li><code>var int mode</code> - camera mode (<code>0</code> = default, <code>1</code> = advanced, <code>2</code> = full)</li> </ul>"},{"location":"scripting/camera/#zmulcam_setnpcs","title":"<code>zMulCam_SetNpcs</code>","text":"<p>Sets the target and source NPC's for the camera <pre><code>func void zMulCam_SetNpcs(var C_NPC source, var C_NPC target) {};\n</code></pre> Parameters</p> <ul> <li><code>var C_NPC source</code> - source NPC</li> <li><code>var C_NPC target</code> - target NPC</li> </ul>"},{"location":"scripting/camera/#zmulcam_settargetnpc","title":"<code>zMulCam_SetTargetNpc</code>","text":"<p>Sets the target NPC for the camera <pre><code>func void zMulCam_SetTargetNpc(var C_NPC npc) {};\n</code></pre> Parameters</p> <ul> <li><code>var C_NPC target</code> - target NPC</li> </ul>"},{"location":"scripting/camera/#zmulcam_setsourcenpc","title":"<code>zMulCam_SetSourceNpc</code>","text":"<p>Sets the source NPC for the camera <pre><code>func void zMulCam_SetSourceNpc(var C_NPC npc) {};\n</code></pre> Parameters</p> <ul> <li><code>var C_NPC npc</code> - source NPC</li> </ul>"},{"location":"scripting/camera/#zmulcam_settargetvob","title":"<code>zMulCam_SetTargetVob</code>","text":"<p>Sets the target Vob for the camera <pre><code>func void zMulCam_SetTargetVob(var string vobName) {};\n</code></pre> Parameters</p> <ul> <li><code>var string vobName</code> - name of the target Vob</li> </ul>"},{"location":"scripting/camera/#zmulcam_setsourcevob","title":"<code>zMulCam_SetSourceVob</code>","text":"<p>Sets the source Vob for the camera <pre><code>func void zMulCam_SetSourceVob(var string vobName) {};\n</code></pre> Parameters</p> <ul> <li><code>var string vobName</code> - name of the source Vob</li> </ul>"},{"location":"scripting/camera/#zmulcam_event","title":"<code>zMulCam_Event</code>","text":"<p>Executes the camera event</p> <p>Warning</p> <p>This function is only available in <code>FULL</code> camera mode. In <code>ADVANCED</code> events are executed during <code>AI_Output()</code> calls.</p> <pre><code>func void zMulCam_Event() {};\n</code></pre>"},{"location":"scripting/camera/#zmulcam_reset","title":"<code>zMulCam_Reset</code>","text":"<p>Resets the camera to the default state <pre><code>func void zMulCam_Reset() {};\n</code></pre></p>"},{"location":"scripting/camera/#example","title":"Example","text":"<p>You can use the camera system e.g. to lock the camera on the NPC for the whole dialog. Below is an example of how to do that:</p> <pre><code>func void DIA_EXAMPLE_3()\n{\n  // Set camera mode to FULL\n  zMulCam_SetMode(2); \n  // Set source and target NPCs\n  zMulCam_SetSourceNpc(hero);\n  zMulCam_SetTargetNpc(self);\n  // Execute camera event\n  zMulCam_Event();\n  // Now the camera is locked on self for the whole dialog\n  AI_Output(self, hero, \"DIA_EXAMPLE_3_00\");//Hey you!\n  AI_Output(hero, self, \"DIA_EXAMPLE_3_01\");//Who, me?\n};\n</code></pre> <ol> <li> <p>Vobs are virtual objects in the game world. Read more on Gothic Modding Community.\u00a0\u21a9</p> </li> </ol>"},{"location":"scripting/dialogs/auto-interface/","title":"Scripting Interface (Auto)","text":"<p>zMultilogue v0.2.0 introduced an auto interface for multilog scripting. This interface allows you to easily create multilogs without the need to manually set everything up.</p>"},{"location":"scripting/dialogs/auto-interface/#how-it-works","title":"How it works","text":"<p>The auto interface works by forwarding the <code>AI_Output()</code> calls to a custom implementation that handles the multilogs automatically. This means that you can use the same <code>AI_Output()</code> calls as you would in a regular dialog, but the multilogs will be created and managed automatically. In addition, automatic camera and NPC turning could be enabled, so you don't have to worry about them.</p>"},{"location":"scripting/dialogs/auto-interface/#how-to-use","title":"How to use","text":"<p>To use the auto interface, you need to enable auto mode in your dialog function. You can enable it wiht <code>zMul_Auto()</code> or <code>zMul_AutoMode()</code>.</p> <pre><code>func void DIA_EXAMPLE_1()\n{\n    var C_NPC npc1; npc1 = Hlp_GetNpc(NONE_001_NPC);\n    var C_NPC npc2; npc2 = Hlp_GetNpc(NONE_002_NPC);\n    zMul_Auto(true);\n    AI_Output(npc1, hero, \"DIA_EXAMPLE_1_00\");//Hey you!\n    AI_Output(hero, npc1, \"DIA_EXAMPLE_1_01\");//Who, me?\n    AI_Output(npc2, hero, \"DIA_EXAMPLE_1_02\");//Do you see anyone else here?\n};\n</code></pre> <p>This will create a multilog with three NPCs (<code>hero</code>, <code>npc1</code>, and <code>npc2</code>) and three outputs. Multilog will be finished automatically when the last output is called. You can also use <code>zMul_Finish()</code> to finish the multilog manually.</p>"},{"location":"scripting/dialogs/auto-interface/#functions","title":"Functions","text":""},{"location":"scripting/dialogs/auto-interface/#zmul_auto","title":"<code>zMul_Auto</code>","text":"<p>Enables/disables automatic multilog mode, camera and NPC turning. <pre><code>func void zMul_Auto(var int enable) {};\n</code></pre> Parameters</p> <ul> <li><code>var int enalbe</code> - TRUE to enable, FALSE to disable</li> </ul>"},{"location":"scripting/dialogs/auto-interface/#zmul_automode","title":"<code>zMul_AutoMode</code>","text":"<p>Enables/disables automatic multilog mode. <pre><code>func void zMul_AutoMode(var int enable) {};\n</code></pre> Parameters</p> <ul> <li><code>var int enalbe</code> - TRUE to enable, FALSE to disable</li> </ul>"},{"location":"scripting/dialogs/auto-interface/#zmul_autoturn","title":"<code>zMul_AutoTurn</code>","text":"<p>Enables/disables automatic NPC turning. <pre><code>func void zMul_AutoTurn(var int enable) {};\n</code></pre> Parameters</p> <ul> <li><code>var int enalbe</code> - TRUE to enable, FALSE to disable</li> </ul>"},{"location":"scripting/dialogs/auto-interface/#zmul_autocam","title":"<code>zMul_AutoCam</code>","text":"<p>Enables/disables automatic camera. <pre><code>func void zMul_AutoCam(var int enable) {};\n</code></pre> Parameters</p> <ul> <li><code>var int enalbe</code> - TRUE to enable, FALSE to disable</li> </ul>"},{"location":"scripting/dialogs/concepts/","title":"Concepts","text":"<p>Some concepts are used throughout the dialogs scripting. This page describes them in detail. If you are not familiar with dialogs scripting, you should read about <code>C_INFO</code> and <code>AI_Output()</code> first.</p>"},{"location":"scripting/dialogs/concepts/#dialog","title":"Dialog","text":"<p>Speaking about a dialog in Gothic we usually mean a <code>C_INFO</code> instance. The dialog is a sequence of <code>AI_Output()</code> calls that are executed in a defined order. Calling the <code>AI_Output()</code> we define the speaker NPC, and the target NPC, but in vanilla scripts we are limited to the dialog owner (<code>self</code>) and the player (<code>other</code>/<code>hero</code>).</p>"},{"location":"scripting/dialogs/concepts/#multilog","title":"Multilog","text":"<p>Multilog is a dialog that is not limited to a single speaker and a single target (same as a Trialog). It allows to have multiple NPCs speaking in a single <code>C_INFO</code> instance. Multilogs are designed to be contained within one <code>C_INFO</code> instance (dailog) and cannot exceed it.</p>"},{"location":"scripting/dialogs/manual-interface/","title":"Scripting Interface (Manual)","text":"<p>From the very beginning, zMultilogue has provided an interface for scripting multilogs based on the LeGo Trialoge package. This interface requires manual setup of multilogs, which can be cumbersome for larger scripts. However, it offers a lot of flexibility and control over the multilogs.</p>"},{"location":"scripting/dialogs/manual-interface/#how-it-works","title":"How it works","text":"<p>The manual interface works fliping the <code>self</code> variable beetween the invited NPCs. That means that you can use the same <code>AI_Output()</code> calls as you would in a regular dialog, but you will be responsible for managing who the <code>self</code> is at the moment.</p>"},{"location":"scripting/dialogs/manual-interface/#how-to-use","title":"How to use","text":"<p>To use the manual interface, you need to setup everything manually. You can do this by inviting NPCs to the multilog using <code>zMul_Invite()</code> and then starting the multilog with <code>zMul_Start()</code>. Then you can use <code>zMul_Next()</code> to switch the <code>self</code> variable to the next NPC in the multilog.</p> <pre><code>func void DIA_EXAMPLE_2()\n{\n    var C_NPC npc1; npc1 = Hlp_GetNpc(NONE_001_NPC);\n    var C_NPC npc2; npc2 = Hlp_GetNpc(NONE_002_NPC);\n    // let's supose that npc1 is the owner of the dialog so there is no need to invite him\n    zMul_Invite(npc2);\n    zMul_Start();\n    // npc1 is now the self\n    AI_Output(self, hero, \"DIA_EXAMPLE_2_00\");//Hey you!\n    AI_Output(hero, self, \"DIA_EXAMPLE_2_01\");//Who, me?\n    zMul_Next(npc2);\n    // npc2 is now the self\n    AI_Output(self, hero, \"DIA_EXAMPLE_2_02\");//Do you see anyone else here?\n    zMul_Finish();\n};\n</code></pre>"},{"location":"scripting/dialogs/manual-interface/#functions","title":"Functions","text":""},{"location":"scripting/dialogs/manual-interface/#zmul_invite","title":"<code>zMul_Invite</code>","text":"<p>Invites NPC to the multilog. <pre><code>func void zMul_Invite(var C_NPC slf)  {};\n</code></pre> Parameters</p> <ul> <li><code>var C_NPC slf</code> - NPC to be invited</li> </ul>"},{"location":"scripting/dialogs/manual-interface/#zmul_start","title":"<code>zMul_Start</code>","text":"<p>Starts the multilog. <pre><code>func void zMul_Start() {};\n</code></pre></p>"},{"location":"scripting/dialogs/manual-interface/#zmul_next","title":"<code>zMul_Next</code>","text":"<p>Changes talking NPC (must be invited first). The <code>self</code> variable will be set to the given NPC.</p> <p>Tip</p> <p>When adding choices to the dialog, <code>self</code> is automatically set to the dialog owner, so you don't need to call this function before <code>Info_AddChoice()</code>.</p> <p><pre><code>func void zMul_Next(var C_NPC npc)  {};\n</code></pre> Parameters</p> <ul> <li><code>var C_NPC npc</code> - Next talking NPC</li> </ul>"},{"location":"scripting/dialogs/manual-interface/#zmul_finish","title":"<code>zMul_Finish</code>","text":"<p>Finishes the multilog.</p> <p>Tip</p> <p>Since <code>v0.1.10</code>, when calling <code>AI_StopProcessInfos()</code> there is no need to call <code>zMul_Finish()</code>.</p> <pre><code>func void zMul_Finish() {};\n</code></pre>"},{"location":"scripting/dialogs/manual-interface/#zmul_wait","title":"<code>zMul_Wait</code>","text":"<p>Makes invited NPC's wait for <code>npc</code> and each other. <pre><code>func void zMul_Wait(var C_NPC npc)  {};\n</code></pre> Parameters</p> <ul> <li><code>var C_NPC npc</code> - NPC to wait for</li> </ul>"},{"location":"scripting/dialogs/manual-interface/#zmul_continue","title":"<code>zMul_Continue</code>","text":"<p>Continues the multilog to the next dialog choice. Must be called before <code>Info_AddChoice()</code>.</p> <p>Deprecated</p> <p>This function is deprecated since <code>v0.1.10</code>.</p> <pre><code>func void zMul_Continue() {};\n</code></pre>"},{"location":"scripting/dialogs/manual-interface/#zmul_autoturn","title":"<code>zMul_AutoTurn</code>","text":"<p>Enables/disables automatic NPC turning.</p> <p>Note</p> <p>When enabled in manual mode, <code>self</code> and hero will be turning to each other.</p> <p><pre><code>func void zMul_AutoTurn(var int enable) {};\n</code></pre> Parameters</p> <ul> <li><code>var int enalbe</code> - TRUE to enable, FALSE to disable</li> </ul>"}]}